#**链表**
##单链表
在单链表中，有两个结点比较特殊，分别是第一个结点和最后一个结点，我们习惯性地将第一个结点叫做头结点，最后一个结点叫做尾结点。其中，头结点用来记录链表的基地址，我们可以通过它来遍历整个链表。而尾结点的特殊之处在于：指针不是指向下一个结点，而是指向一个空地址NULL，表示这是链表的最后一个结点。

##循环链表
循环链表是一种特殊的单链表。它与单链表的唯一区别就在尾结点。单链表的尾结点指针指向空地址，表示这是最后的结点了。而循环链表的尾结点指针指向链表的头结点，像一个环一样首尾相连，所以叫做"循环"链表。与单链表相比，循环链表的优点是从链尾到链头比较方便，当要处理的数据具有环型结构特点时，就特别适合采用循环链表，比如著名的约瑟夫问题。
##双向链表
单链表只有一个方向，结点只有一个后继指针next指向后面的节点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。由于双向链表需要额外的两个空间来存储后继结点个前驱结点，所以，存储同样多的数据，双向链表比单向链表占用更多的内存空间。虽然浪费空间，但是双向链表支持双向遍历，这带来了双向链表操作的灵活性。

双向链表适合解决哪种问题？

双向链表可以支持O(1)时间复杂度的情况下找到前驱结点，正是这样一个原因，使得双向链表在某些情况下的插入、删除等操作比单链表简单、高效。在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：a)删除结点中“值等于某个给定值”的结点；b)删除给定指针指向的结点对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过之前说的指针操作将其删除。尽管单纯的删除时间复杂度是O(1)，但是遍历查找的时间是主要的耗时点，对应的时间复杂度为O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为O(n)。

对于第二种情况，我们已经找到了要删除的结点，但是删除某个结点q需要知道其前驱结点，而单链表并不支持直接获取前驱结点，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到p->next=q,说明p是q的前驱结点，但是对于双向链表来说，这种情况就比较有优势了，因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要O(n)的时间复杂度，而双向链表只需要在O(1)的时间复杂度内就搞定了。

同理，我们在链表的某个指定结点前面插入一个结点，双向链表可以再O(1)的时间复杂度内搞定，而单向链表需要O(n)的时间复杂度。java LinkedHashMap容器的实现原理使用了双向链表这种数据结构。这里有一个很重要的思想：用空间换时间的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高，但时间复杂度相对较低的算法或者数据结构。

对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化，而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。


##双向循环链表
循环链表和双向链表可以整合成新的版本：双向循环链表。

##链表的五个常用操作
1. 单链表反转
2. 链表中环的检测
3. 两个有序的链表合并
4. 删除链表倒数第n个结点
5. 求链表的中间结点
---
##链表技巧



